# tuyin parser generator

#### 介绍

一个还可以的Parser生成器，为高性能设计，实现了antlr4的ALL(*)类似的文法推导能力且无回溯，当文法定义复杂度越高时Tuyin性能将越优于Antlr4，Tuyin不是基于LL\LR以及其变种，通过一种新的图解算法计算出公因式与冲突在通过向前或向后移进达到无回溯使性能与文法复杂度无关，没有论文也不会写，意思是只要你DSL无错生成了代码怎么写定义也不会降低解析速度，不用担心DSL安排不合理会有冲突，只要定义不完全一致就不会有，产生冲突也会在控制台精准的告诉你哪行与哪行有冲突和其原因，如果是生成parser时分析超时了在设置里改写%parser.timeout=10000000000，反正大一点就行了。

1. Program.cs 测试代码入口
2. samll.md 小文件解析测试
3. large.md 大文件解析测试
4. markdown.txt Tuyin Parser DSL
5. markdwon.g4 Antlr4 DSL
6. generate_tuyin_parser.bat 生成对应的tuyin parser
7. json2.txt Tuyin json parser dsl
8. ir.txt 复杂parser

#### 已知问题

1.parser解决中缀问题

typedName '(' args ')' func_body	^new FuncDecl($1, $3, $5)

typedName '(' args ')' METAID func_body	^new FuncDecl($1, $3, $6, new MetadataReference($5, mInput))

2.parser解决循环插入问题

3.添加新的元数据机制[详情参考Tuyin.IR.Compiler项目]

4.新的外部函数机制[详情参考Tuyin.IR.Compiler项目]

5.完成updown2ciryle

6.更新wasm编译，真正支持循环结构[详情参考Tuyin.IR.Compiler项目]

#### 更新日志 2023-10-3

1.解决了解析相同路径产生的BUG

现在可以更好的支持以下路径

[ a ]

[ a ] b 

2.添加了一个复杂的文法DSL,ir.txt

#### 性能对比

##### 测试文件

1. small_json.json（183字节）
2. large_json.json (4.41m)
3. small.md (252字节)
2. large.md（17m） 

##### 测试环境

Intel(R) Xeon(R) CPU E3-1231 v3 @ 3.40GHz (8CPUs)

##### 测试结果

||Antlr4|Newtonsoft|Tuyin|
|---|---|---|---|
|json_samll|110ms|91ms|7ms|
|json_large|997ms|267ms|56ms|
|md_small|9ms|-|8ms|
|md_large|16132ms|-|564ms|

###### 关于json_samll为何解析时间这么长，是因为还没JIT啊！

#### 如何使用

1. 观察markdown.txt中DSL文法
2. 自己写一个DSL
3. 修改generate_tuyin_parser.bat中所使用的的DSL
4. 运行generate_tuyin_parser.bat生成parser单文件代码

#### 参数解释

-------------------------------------------------
- 设置生成的分析器入口点会以parse()函数生成(必须)
-------------------------------------------------
%parser.entry=sampile_token_test

-------------------------------------------------
- 设置生成的分析器类型名(默认为{%parser.entry}Parser)
-------------------------------------------------
%parser.class=test1

-------------------------------------------------
- 设置产出格式(默认csharp)
- 如果设置为csharp|c...,则会生成代码
- 如果设置为dot则会生成dot图数据
- 值为时opencl将会强制%parser.iterative=true
- 且所有递归将转为循环形式改写
- #### 该测试程序只支持csharp如需其他target请与我联系
-------------------------------------------------
%parser.target=csharp

-------------------------------------------------
- 设置是否以迭代算法形式输出（默认false)
- 当此选项为true时，会拆分流程形成迭代步骤
- 原结构和parser.keep将强制失效，保留parse入口
- #### 该测试程序不提供此项功能，如需要请与我联系
-------------------------------------------------
%parser.iterative=true

-------------------------------------------------
- 内联深度(默认-1)                        
- 如果设置为0则代表关闭内联
- 如果设置为-1则代表无限深度
- 如果设置为x则代表内联步数超出x时取消内联
- 内联深度越高生成的代码量越大，但同时性能越高
- #### 该测试程序不提供此项功能，如需要请与我联系
-------------------------------------------------
%parser.inline=0

-------------------------------------------------
- 生成表超时设置,单位毫秒(默认5000)
- 如果超时将抛出错误
- 避免复杂声明式NP问题引发等待过长问题
-------------------------------------------------
%parser.timeout=2000

-------------------------------------------------
- 设置是否保持原结构(默认false)
- 如果设置为false，则输出结构可能会被优化掉
- 如果只使用parse()，推荐默认保持为false
-------------------------------------------------
%parser.keep=true

-------------------------------------------------
- 设置是否最小化(默认true)
- 如果设置为false，生成结果可能过大，不推荐修改
-------------------------------------------------
%parser.minimize=true

-------------------------------------------------
- 设置是否以NFA模式输出(默认false)         
- 如果设置为true,性能优化将失效
- 推荐不修改此选项
- #### 废弃
-------------------------------------------------
%parser.nfa=false

-------------------------------------------------
- 设置是否尝试以转跳表构建分支(默认true)
- 该选项为true时会将对Token的索引进行紧凑化
- 以C#编译器为例，它大概支持7至10区间的switch表
- 比如switch(a) a>0&&a<10 编译时会将分支映射成区间
- switch相当于对当前进程地址做了偏移避免全部判断
- 开启此选项会加快程序运行性能略微牺牲内存空间
- #### 该测试程序不提供此项功能，如需要请与我联系
-------------------------------------------------
%parser.table=false

-------------------------------------------------
- 设置是否支持多义词(默认false)
- 当此选项为true时则支持以下歧义Token
- abcde				^ID
- abcde				^VAR
- 123				^NUM
- rule id_var		转换为		rule id_var
-	: VAR NUM		^$2    ->		: VAR_ID (NUM|ε)
-	| ID			^$1				;
-	;
- 其中VAR_ID是被自动创建的Token用于解决歧义问题
- #### 该测试程序不提供此项功能，如需要请与我联系
-------------------------------------------------
%token.clarity=true

-------------------------------------------------
- 设置是否支自动声明Token(默认false)
- 比如:
-	rule foo
-		: literal ....
- 其中literal并没有在文件内直接声明
- 此设置为true时，由于literal是唯一路径
- 所以会自动创建该Token并引用，否则会抛出错误
-------------------------------------------------
%token.auto=true

-------------------------------------------------
- 设置是否添加状态记录步(默认false)
- 此项为true时会在生成调用State(%1,%2..)
- %1 int index 从输入源该索引位置起
- %2 ushort state 目标状态
- .. formals
-------------------------------------------------
%parser.state=false

-------------------------------------------------
- 设置是否添加token被匹配时回调
- 此项为true时会在匹配token成功时调用一次OnMatch
-------------------------------------------------
%token.callback=true

-------------------------------------------------
- 设置是否设置为Debug模式
- 此项为true时生成的代码会额外添加所使用的边注释
-------------------------------------------------
%token.debug=false

-------------------------------------------------
- 使用formal时会将所有分析函数添加一个传参
- 比如 parse将从char*,int变为char*,int,Type
- Type名由生成器管理根据顺序定义为formal0-formalN
- 所有反馈函数,如Coloring或是Metadata将会把该
-   参数传递回去,如下:
- State(int index...			Type formal0)
- GetState(int index...			Type formal0)
- Coloring(int start...			Type formal0)
- ReportError(SourceSpan span.. Type formal0)
- ...
- Metadata(int index...			Type formal0)
-------------------------------------------------
%formal Type

#### 未来计划

1. 添加c\js\python\lua和dot流程图的target
2. 优化...规则生成的代码处理的方式
3. 简化生成的代码，更加靠近手写风格
4. 继续优化提高性能
